# [바이브코딩 클래스] 엔터프라이즈 수준의 AI 에이전트 개발 표준 워크플로우

본 가이드는 기획 문서(WBS/SRS)가 준비된 상태에서, AI 에이전트(Cursor)와 협업하여 백엔드 및 AI 기능을 구현하고 배포하는 \*\*표준 엔지니어링 절차(Standard Engineering Process)\*\*를 다룹니다.

## 1\. 워크플로우 단계별 실행 가이드

각 단계는 \*\*'기획(Planning) → 설계(Design) → 구현(Implementation) → 검증(Verification)'\*\*의 순환 구조를 가지며, 에이전트에게 명확한 R\&R(역할과 책임)을 부여하는 것이 핵심입니다.

| 단계 | 워크플로우 명칭 | 핵심 프롬프트 요약 (User Action) | 주요 작업 내용 & 결과 (Agent Outcome) |
| :-- | :-- | :-- | :-- |
| **1** | **환경 설정 및 규칙 정의**<br>(Environment Setup) | "기존 @rules를 백엔드/AI 기술 스택에 맞춰 수정하고, 프로젝트 README를 작성해줘." | • **규칙 최적화:** `.cursor/rules`를 백엔드 개발용으로 재정의<br>• **문서화:** 프로젝트 메인 README.md 완성 |
| **2** | **PM 자동화 및 이슈 관리**<br>(Project Management) | "WBS 문서를 참조하여 GitHub Issue를 발행하고, gh 명령어로 직접 프로젝트 보드에 등록해줘." | • **이슈 동기화:** WBS 의존성을 분석하여 GitHub Issue 생성<br>• **일정 관리:** `gh` CLI로 프로젝트 로드맵/일정 업데이트 |
| **3** | **상세 설계 및 기능 구현**<br>(Detail Design & Dev) | "Issue \#006에 대해 3-Tier 패턴을 적용하고, ERD/CLD/ORM 다이어그램을 먼저 그린 후 구현해줘." | • **시각적 설계:** 구현 전 ERD(데이터), CLD(로직) 도식화<br>• **구조적 구현:** 설계에 기반한 Spring Boot/Auth 모듈 코딩 |
| **4** | **Git 라이프사이클 관리**<br>(Git Lifecycle) | "커밋/푸시 규칙을 참조하여 PR을 생성하고, 코드 리뷰 문서를 작성해줘." | • **형상 관리:** 컨벤션을 준수한 Commit 및 PR 생성<br>• **리뷰 자동화:** 변경 사항 요약 및 리뷰용 문서 자동 생성 |
| **5** | **보안 및 비기능 구현**<br>(Security & NFR) | "AI/DB 연결을 위한 환경변수 보안 전략을 수립하고, 성능 테스트(NFR) 이슈를 추적해줘." | • **보안 설정:** `.env` 및 Secret 관리 전략 수립<br>• **비기능 요건:** 응답 속도 등 성능 지표(NFR) 점검 |
| **6** | **품질 보증 및 정합성**<br>(QA & Traceability) | "구현된 내용이 SRS 문서의 요구사항과 일치하는지 추적성(Traceability)을 검증해줘." | • **정합성 검증:** 기획(SRS) vs 구현(Code) 간 상호 추적<br>• **완료 처리:** 원격 저장소 이슈 상태를 'Completed'로 동기화 |
| **7** | **자산화 및 교육**<br>(Archiving) | "전체 워크플로우를 교육용 가이드 문서로 정리해줘." | • **지식 자산화:** 개발 과정을 재사용 가능한 가이드/교안으로 변환 |

-----

## 2\. 에이전트 협업의 5대 핵심 전략 (Best Practices)

성공적인 AI 협업을 위해 반드시 준수해야 할 5가지 모범 전략입니다. 이 전략들은 AI의 환각을 줄이고 결과물의 품질을 엔터프라이즈급으로 유지시켜 줍니다.

### **A. 룰(Rule) 기반의 자율적 행동 제어 (Rule-Based Autonomy)**

프롬프트마다 일일이 지시하는 것이 아니라, 프로젝트 시작 전 \*\*`.cursor/rules`\*\*에 코딩 컨벤션, 아키텍처 패턴, 커밋 규칙 등을 명시합니다.

  * **효과:** 에이전트가 "알아서" 규칙을 참조하므로, 개발자는 반복적인 스타일 교정 대신 비즈니스 로직에 집중할 수 있습니다.

### **B. 문서 주도 개발과 직접 제어 (Docs-Driven & CLI Control)**

기획 문서(WBS, SRS)를 에이전트에게 입력(Context)으로 제공하고, 에이전트가 이를 해석해 **직접 `gh` 명령어(CLI)를 수행**하게 합니다.

  * **효과:** 단순 코딩을 넘어 이슈 생성, 일정 관리 등 PM(Project Manager)의 영역까지 자동화하여 개발 생산성을 극대화합니다.

### **C. "설계 후 구현" 원칙 준수 (Design-First, Code-Later)**

복잡한 기능 구현 시 바로 코드를 요청하지 않고, **ERD(데이터), CLD(로직 흐름), ORM(매핑)** 다이어그램을 먼저 그리도록 지시합니다.

  * **효과:** 시각적 구조를 먼저 합의함으로써 논리적 오류를 사전에 차단하고, 스파게티 코드가 생성되는 것을 방지합니다.

### **D. 비기능 요구사항의 조기 통합 (Shift-Left Security & NFR)**

기능 개발과 동시에 **보안(Secret Management)**, **성능(Performance)**, **테스트(Test)** 등 비기능적 요소(NFR)를 함께 고려하도록 요청합니다.

  * **효과:** 개발 후반부에 보안 구멍이나 성능 이슈를 발견하여 재작업하는 비용을 획기적으로 줄여줍니다.

### **E. 요구사항 추적성 확보 (Traceability Verification)**

구현이 완료된 후, 해당 코드가 최초의 \*\*요구사항 명세서(SRS)\*\*의 어느 항목을 충족하는지 역추적하여 검증합니다.

  * **효과:** 개발된 기능이 기획 의도와 부합하는지 보증하며, 프로젝트의 완결성을 높이는 전문 엔지니어링 절차입니다.