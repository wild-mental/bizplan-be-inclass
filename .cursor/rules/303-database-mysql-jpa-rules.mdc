---
description: Rules for SQLite Database design and JPA/Hibernate usage
globs: ["**/*.java", "**/*.sql"]
alwaysApply: false
---
# Database & JPA Rules

## 1. Database Design (SQLite)
- **Database:** SQLite (파일 기반, 개발/운영/테스트 모두 동일)
- **Dialect:** `org.hibernate.community.dialect.SQLiteDialect`
- **Naming Convention:**
  - Tables: `snake_case` (plural nouns, e.g., `users`, `projects`).
  - Columns: `snake_case` (e.g., `user_id`, `created_at`).
- **Primary Keys:** Use UUIDs (TEXT or BLOB) for distributed ID safety. SQLite는 AUTOINCREMENT 대신 INTEGER PRIMARY KEY 사용 가능하지만, UUID 권장.
- **Audit Columns:** All tables should have `created_at` and `updated_at` (TIMESTAMP 타입).
- **Indexes:** Always index Foreign Keys and columns used in `WHERE` or `ORDER BY` clauses.
- **Data Types:** 
  - Use `TEXT` for strings (VARCHAR 대신)
  - Use `INTEGER` for numbers
  - Use `TIMESTAMP` for dates (DATETIME 대신)
  - Use `BLOB` for binary data

## 2. JPA / Hibernate Best Practices
- **Fetch Strategy:**
  - Explicitly set `fetch = FetchType.LAZY` for `@ManyToOne` and `@OneToOne`. (Default is EAGER, which causes performance issues).
  - Default `@OneToMany` is already LAZY.
- **N+1 Problem:**
  - Detect with logging (Hibernate SQL logs).
  - Fix using `JOIN FETCH` in JPQL or `@EntityGraph` for read operations.
- **Transactions:**
  - Apply `@Transactional(readOnly = true)` at the class level for Services.
  - Override with `@Transactional` on specific modification methods (create/update/delete).
- **Entities:**
  - Use `@Entity` with `@Table(name = "...")`.
  - Avoid business logic in Entity setters. Use domain methods (e.g., `user.changePassword(...)`).

## 3. Migration
- Use **Flyway** or **Liquibase** for schema version control.
- Never modify existing migration files; create new V+1 files.
